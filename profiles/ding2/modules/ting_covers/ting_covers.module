<?php
/**
 * @file
 * Provide functionality and page callbacks for retrieving covers for Ting
 * objects and collections
 */

// Default cache lifetime for covers (24 timer).
define('TING_COVERS_DEFAULT_CACHE_LIFETIME', 86400);

// Load field module hooks.
module_load_include('inc', 'ting_covers', 'ting_covers.field');

/**
 * Implements hook_menu().
 */
function ting_covers_menu() {
  $items = array();

  $items['ting/covers'] = array(
    'title' => 'Retreives cover for Ting objects',
    'page callback' => 'ting_covers_objects',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'ting_covers.pages.inc',
  );

  $items['admin/config/ting/covers'] = array(
    'title' => 'Covers',
    'description' => 'Configure how covers are handled.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_covers_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_covers.admin.inc',
  );

  $items['admin/config/ting/covers/setttings'] = array(
    'title' => 'Settings',
    'description' => 'Configure how covers are handled.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/config/ting/covers/addi'] = array(
    'title' => 'ADDI service',
    'description' => 'Configure integration with the ADDI service.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_covers_admin_addi_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_covers.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ting_covers_theme() {
  return array(
    'ting_object_cover' => array(
      'render element' => 'elements',
      'file' => 'ting_covers.theme.inc',
    ),
  );
}

/**
 * Implements hook_cron().
 */
function ting_covers_cron() {
  _ting_covers_delete_old_files($_SERVER['REQUEST_TIME'] - variable_get('ting_covers_cache_lifetime', TING_COVERS_DEFAULT_CACHE_LIFETIME));
}

/**
 * Implements hook_ding_install_tasks().
 */
function ting_covers_ding_install_tasks() {
  module_load_include('inc', 'ting_covers', 'ting_covers.admin');
  return array(
    'ting_covers_admin_addi_settings_form' => array(
      'display_name' => st('ADDI service settings'),
      'type' => 'form',
      'file' => drupal_get_path('module', 'ting_covers') . '/ting_covers.admin.inc',
    ),
  );
}

/**
 * Template preprocessor.
 */
function ting_covers_preprocess_ting_object(&$variables) {
  /*
   * Add the image style as a class, allowing templates to react on the size.
   */
  if (isset($variables['elements']['ting_cover'][0])) {
    $variables['classes_array'][] = drupal_html_class('imagestyle-' . $variables['elements']['ting_cover'][0]['#image_style']);
  }
}

/**
 * Delete ting covers files.
 *
 * @todo: handle image styles better and use API to flush expired images.
 *
 * @param int $time
 *   Timestamp where older files will be deleted.	Omit or set to NULL to delete
 *   all files.
 */
function _ting_covers_delete_old_files($time = NULL) {
  // Collect potential locations of cover folders.
  $files_dir = file_default_scheme() . '://';
  $image_dirs = array($files_dir);

  $styles_dir = $files_dir . 'styles';
  foreach (scandir($styles_dir) as $style_dir) {
    $style_dir = $styles_dir . DIRECTORY_SEPARATOR . $style_dir . DIRECTORY_SEPARATOR . 'public' . DIRECTORY_SEPARATOR;
    if (is_dir($style_dir)) {
      $image_dirs[] = $style_dir;
    }
  }

  // Collect cover files.
  $cover_files = array();
  foreach ($image_dirs as $uri) {
    $ting_covers_dir = $uri . 'ting' . DIRECTORY_SEPARATOR . 'covers';
    if (is_dir($ting_covers_dir)) {
      $cover_files = array_merge($cover_files, file_scan_directory($ting_covers_dir, "/./"));
    }
  }

  // Delete obsolete files.
  foreach ($cover_files as $file) {
    if (!$time || (filemtime($file->uri) < $time)) {
      file_unmanaged_delete($file->uri);
    }
  }
}

/**
 * Return the path to the cover of the object.
 */
function ting_covers_object_path($object_id) {
  return file_default_scheme() . '://ting' . DIRECTORY_SEPARATOR . 'covers' . DIRECTORY_SEPARATOR . 'object' . DIRECTORY_SEPARATOR . md5($object_id) . '.jpg';
}

/**
 * Get covers for an array of local ids.
 *
 * @param array $requested_covers
 *   Array keyed by local id with each element being an array with one key.
 *     image_style: The name of the image style to get the image in.
 *
 * @return array
 *   Array of the same type as input, but with the key 'url' added.
 *   This key has the url of the image with that image style.
 *   Results are in order.
 */
function ting_covers_load($requested_covers) {
  $covers = array();
  $image_styles = array();
  $missing_images_local_ids = array();

  foreach ($requested_covers as $local_id => $cover_info) {
    // Determine if the local id is a known negative.
    if (cache_get('ting_covers:' . $local_id, FALSE)) {
      break;
    }

    $path = ting_covers_object_path($local_id);
    if (file_exists($path)) {
      // If we we already have a valid cover image w/o style then just use it.
      $covers[$local_id] = array(
        'image_style' => $cover_info['image_style'],
        'url' => image_style_url($cover_info['image_style'], $path),
      );
    }
    else {
      // Mark the image for retrieval.
      $missing_images_local_ids[] = $local_id;

      // Image style to match later one.
      $image_styles[$local_id] = $cover_info['image_style'];
    }
  }

  // Try to download the missing images.
  $addi = FALSE;
  $retrieved = array();
  // Provider might implement getting covers.
  if (ding_provider_implements('cover', 'get')) {
    $retrieved = ding_provider_invoke('cover', 'get', $missing_images_local_ids);
  }
  // Otherwise, fallback on addi.
  else {
    $service = new AdditionalInformationService(variable_get('addi_wsdl_url'), variable_get('addi_username'), variable_get('addi_group'), variable_get('addi_password'));

    // Local ids = Faust numbers. Library object identifiers can be confusing.
    $retrieved = $service->getByLocalIdentifier($missing_images_local_ids);
    $addi = TRUE;
  }

  // Exceptions should only be thrown if something is so wrong,
  // that no images can be fetched whatsoever.
  try {
    foreach ($missing_images_local_ids as $local_id) {
      $file = FALSE;
      // If we are using ADDI, we have to extract uri,
      // and download image.
      if ($addi) {
        // Try to extract the image url from the result.
        $source_url = FALSE;
        if (isset($retrieved[$local_id]) && $ai = $retrieved[$local_id]) {
          if ($ai->detailUrl) {
            $source_url = $ai->detailUrl;
          }
          elseif ($ai->thumbnailUrl) {
            $source_url = $ai->thumbnailUrl;
          }
        }

        // Try to download the image locally.
        if ($source_url && $download = _ting_covers_pages_fetch_image(ting_covers_object_path($local_id), $source_url)) {
          $file = $download;
        }
      }
      // If not, get file from provider.
      else {
        $file = $retrieved[$local_id];
      }

      // No cover image found? Cache this for future reference to avoid
      // unnecessary requests.
      if (!$file) {
        cache_set('ting_covers:' . $local_id, 1, 'cache', $_SERVER['REQUEST_TIME'] + TING_COVERS_DEFAULT_CACHE_LIFETIME);
        continue;
      }

      // Generate a path corresponding to the downloaded image, styled.
      $covers[$local_id] = array(
        'image_style' => $image_styles[$local_id],
        'url' => image_style_url($image_styles[$local_id], $file),
      );
    }
  }
  catch (Exception $e) {
    if ($addi) {
      watchdog('ting_covers', 'Unable to retrieve covers from ADDI: %message', array('%message' => $e->getMessage()), WATCHDOG_ERROR);
    }
    else {
      watchdog('ting_covers', 'Unable to retrieve covers from Provider: %message', array('%message' => $e->getMessage()), WATCHDOG_ERROR);
    }
  }

  // Return all image information.
  return $covers;
}

/**
 * Helper function to fetch and save a cover image file.
 *
 * @see image_style_create_derivative()
 *
 * @param string $filename
 *   File name, including its path within Drupal's file folder.
 * @param string $image_url
 *   URL for the source image file.
 *
 * @return mixed
 *   A file object or FALSE on error.
 */
function _ting_covers_pages_fetch_image($filename, $image_url) {
  $result = drupal_http_request($image_url);

  // Bail if the HTTP request failed.
  if ($result->code != 200) {
    return FALSE;
  }

  // Get the folder for the final location of this preset.
  $directory = dirname($filename);

  // Build the destination folder tree if it doesn't already exist.
  if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
    watchdog('ting_covers', 'Failed to create directory: %directory', array('%directory' => $directory), WATCHDOG_ERROR);
    return FALSE;
  }

  return file_unmanaged_save_data($result->data, $filename, FILE_EXISTS_REPLACE);
}
