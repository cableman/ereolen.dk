<?php
/**
 * @file
 * Provide functionality and page callbacks for retrieving covers for Ting
 * objects and collections
 */

// Default cache lifetime for covers (24 timer).
define('TING_COVERS_DEFAULT_CACHE_LIFETIME', 86400);

// Load field module hooks.
module_load_include('inc', 'ting_covers', 'ting_covers.field');

/**
 * Implements hook_menu().
 */
function ting_covers_menu() {
  $items = array();

  $items['ting/covers'] = array(
    'title' => 'Retreives cover for Ting objects',
    'page callback' => 'ting_covers_objects',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'ting_covers.pages.inc',
  );

  $items['admin/config/ting/covers'] = array(
    'title' => 'Covers',
    'description' => 'Configure how covers are handled.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ting_covers_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ting_covers.admin.inc',
  );

  $items['admin/config/ting/covers/setttings'] = array(
    'title' => 'Settings',
    'description' => 'Configure how covers are handled.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ting_covers_theme() {
  return array(
    'ting_object_cover' => array(
      'render element' => 'elements',
      'file' => 'ting_covers.theme.inc',
    ),
  );
}

/**
 * Implements hook_cron().
 */
function ting_covers_cron() {
  _ting_covers_delete_old_files($_SERVER['REQUEST_TIME'] - variable_get('ting_covers_cache_lifetime', TING_COVERS_DEFAULT_CACHE_LIFETIME));
}

/**
 * Template preprocessor.
 */
function ting_covers_preprocess_ting_object(&$variables) {
  /*
   * Add the image style as a class, allowing templates to react on the size.
   */
  if (isset($variables['elements']['ting_cover'][0])) {
    $variables['classes_array'][] = drupal_html_class('imagestyle-' . $variables['elements']['ting_cover'][0]['#image_style']);
  }
}

/**
 * Delete ting covers files.
 *
 * @todo: handle image styles better and use API to flush expired images.
 *
 * @param int $time
 *   Timestamp where older files will be deleted.	Omit or set to NULL to delete
 *   all files.
 */
function _ting_covers_delete_old_files($time = NULL) {
  // Collect potential locations of cover folders.
  $files_dir = file_default_scheme() . '://';
  $image_dirs = array($files_dir);

  $styles_dir = $files_dir . 'styles';
  foreach (scandir($styles_dir) as $style_dir) {
    $style_dir = $styles_dir . DIRECTORY_SEPARATOR . $style_dir . DIRECTORY_SEPARATOR . 'public' . DIRECTORY_SEPARATOR;
    if (is_dir($style_dir)) {
      $image_dirs[] = $style_dir;
    }
  }

  // Collect cover files.
  $cover_files = array();
  foreach ($image_dirs as $uri) {
    $ting_covers_dir = $uri . 'ting' . DIRECTORY_SEPARATOR . 'covers';
    if (is_dir($ting_covers_dir)) {
      $cover_files = array_merge($cover_files, file_scan_directory($ting_covers_dir, "/./"));
    }
  }

  // Delete obsolete files.
  foreach ($cover_files as $file) {
    if (!$time || (filemtime($file->uri) < $time)) {
      file_unmanaged_delete($file->uri);
    }
  }
}

/**
 * Return the path to the cover of the object.
 */
function ting_covers_object_path($object_id) {
  return file_default_scheme() . '://ting' . DIRECTORY_SEPARATOR . 'covers' . DIRECTORY_SEPARATOR . 'object' . DIRECTORY_SEPARATOR . md5($object_id) . '.jpg';
}

/**
 * Get covers for an array of ids.
 *
 * @param array $requested_covers
 *   Array keyed by id with each element being an array with one key.
 *     image_style: The name of the image style to get the image in.
 *
 * @return array
 *   Array of the same type as input, but with the key 'url' added.
 *   This key has the url of the image with that image style.
 */
function ting_covers_load($requested_covers) {
  $entities = array();
  $covers = array();

  // Create array of loaded entities for passing to hooks.
  foreach ($requested_covers as $id => $cover_info) {
    // Determine if the local id is a known negative.
    if (cache_get('ting_covers:' . $id, FALSE)) {
      continue;
    }

    // If we we already have a valid cover image, use it.
    $path = ting_covers_object_path($id);
    if (file_exists($path)) {
      $covers[$id] = $path;
      continue;
    }

    // If all else fails, try to fetch cover image from hooks.
    $entities[$id] = ding_entity_load($id);
  }

  // Go through all modules that implement hook.
  foreach (module_implements('ting_covers') as $module) {
    // Fetch covers from hook.
    $covers_found = module_invoke($module, 'ting_covers', $entities);
    $covers += $covers_found;

    // Remove elements from entities, where a cover has been found.
    foreach (array_keys($covers_found) as $id) {
      if (isset($entities[$id])) {
        unset($entities[$id]);
      }
    }
  }

  // Mark all remaining as not found in cache.
  foreach ($entities as $id => $entity) {
    cache_set('ting_covers:' . $id, 1, 'cache', $_SERVER['REQUEST_TIME'] + TING_COVERS_DEFAULT_CACHE_LIFETIME);
  }

  // Go through all found covers, and return them in the correct style.
  $return = array();
  foreach ($covers as $id => $cover) {
    $style = $requested_covers[$id]['image_style'];
    $return[$id] = array(
      'image_style' => $style,
      'url' => image_style_url($style, $cover),
    );
  }

  return $return;
}
