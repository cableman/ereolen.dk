<?php

/**
 * @file
 * Code for the eReolen review module feature.
 */

/**
 * Implements hook_cron().
 *
 * Make sure we have reviews fetched and cached.
 */
function reol_review_cron() {
  // Fetch the newest.
  reol_review_fetch_and_queue(20, 0);
  // Fetch legacy reviews, if we haven't already.
  reol_review_fetch_old();

  // Reschedule old reviews we didn't find locally for periodic recheck.
  $days = variable_get('reol_review_reshedule_unknown_days', 7);
  $timestamp = REQUEST_TIME - ($days * 86400);

  $query = db_select('reol_review_reviews', 'r')
    ->fields('r', array('rrid'))
    ->condition('ding_entity_id', '')
    ->condition('process', 0)
    ->condition('processed', $timestamp, '<')
    ->range(0, 50);

  $rrids = array();
  $queue = DrupalQueue::get('reol_review_old');
  foreach ($query->execute() as $row) {
    $queue->createItem($row->rrid);
    $rrids[] = $row->rrid;
  }

  // Set to being processed.
  if ($rrids) {
    db_update('reol_review_reviews')
      ->fields(array('process' => 1))
      ->condition('rrid', $rrids)
      ->execute();
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function reol_review_cron_queue_info() {
  // We're running with two queues, to ensure that new entries are
  // always processed, even when there's old in the queue.
  $queues['reol_review_new'] = array(
    'worker callback' => 'reol_review_process_queue',
    'time' => 120,
  );

  $queues['reol_review_old'] = array(
    'worker callback' => 'reol_review_process_queue',
    'time' => 120,
  );

  return $queues;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function reol_review_ctools_plugin_directory($owner, $plugin_type) {
  return 'plugins/' . $plugin_type;
}

/**
 * Fetch reviews from Litteratursiden.
 *
 * @param int $items
 *   Number of items to return.
 * @param int $start
 *   Offset to start list at.
 *
 * @return array
 *   The data returned from feed.
 */
function reol_review_fetch_reviews($items, $start) {
  $feed_url = variable_get('reol_review_litteratursiden_feed', 'http://www.litteratursiden.dk/service/recommendations');
  if ($feed_url) {
    $feed_url = drupal_parse_url($feed_url);
    $feed_url['query']['count'] = $items;
    $feed_url['query']['offset'] = $start;

    $curl = curl_init();

    curl_setopt($curl, CURLOPT_HEADER, 0);
    // Set curl to return the data instead of printing it to the browser.
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($curl, CURLOPT_URL, url($feed_url['path'], $feed_url));
    $data = curl_exec($curl);
    curl_close($curl);
    return json_decode($data);
  }
  return array();
}

/**
 * Get a random review.
 *
 * @param string $type
 *   The type to get a random review for. If not set, return one
 *   random result in all types.
 *
 * @return StdClass
 *   The review randomly chosen. The related ting_entity will be available on
 *   $review->ting_entity.
 */
function reol_review_get_random_reviews($type = NULL, $count = 1) {
  $query = db_select('reol_review_reviews', 'r')
    ->fields('r')
    ->condition('processed', 0, '<>')
    ->condition('ding_entity_id', '', '<>')
    ->orderRandom();

  if ($type) {
    $query->condition('type', $type);
  }

  $res = $query->execute();

  $result = array();
  while ($review = $res->fetch()) {
    $review->ting_entity = ding_entity_load($review->ding_entity_id);
    if ($review->ting_entity) {
      $result[] = $review;
    }
    else {
      // If we can't find the object anymore, remove the review from
      // selection.
      db_update('reol_review_reviews')
        ->fields(array(
          'process' => $review->process,
          'processed' => $review->processed,
          'type' => $review->type,
          'ding_entity_id' => '',
        ))
        ->condition('rrid', $review->rrid)
        ->execute();
    }
    if (count($result) >= $count) {
      break;
    }
  }

  return $result;
}

/**
 * Fetch old reviews by going backwards in feed.
 */
function reol_review_fetch_old() {
  $offset = variable_get('reol_review_fetch_offset', -1);
  // -1 means we're all done.
  if ($offset < 0) {
    return;
  }

  // Do 5 fetches, giving us 100 reviews.
  $iterations = 5;
  for ($i = 0; $i < $iterations; $i++) {
    if (!reol_review_fetch_and_queue(20, $offset, 'reol_review_old')) {
      // Reached the end. Make a note and return.
      variable_set('reol_review_fetch_offset', -1);
      return;
    }
    $offset += 20;
    // Setting on each iteration, in case we get interrupted.
    variable_set('reol_review_fetch_offset', $offset);
  }
}

/**
 * Fetch and queue reviews for later processing.
 */
function reol_review_fetch_and_queue($count, $offset, $queue_name = 'reol_review_new') {
  $reviews = reol_review_fetch_reviews($count, $offset);

  if (empty($reviews) || isset($reviews->error) && !$reviews->error) {
    return FALSE;
  }

  $queue = DrupalQueue::get($queue_name);
  // Create a lookup table of those we already have.
  $review_links = array();
  foreach ($reviews as $review) {
    $review_links[] = $review->link;
  }

  $existing = db_select('reol_review_reviews', 'r')
    ->fields('r', array('link', 'link'))
    ->condition('link', $review_links)
    ->execute()
    ->fetchAllKeyed();

  foreach ($reviews as $review) {
    // Skip existing, and invalid reviews..
    if ($existing[$review->link] ||
        empty($review->isbn) ||
        empty($review->link)) {
      continue;
    }
    $isbn = trim($review->isbn);
    $link = trim($review->link);

    // Skip if they're too long. Not using drupal_strlen() as we want
    // the ASCII length, not multibyte length.
    if (strlen($isbn) > 13 || strlen($link) > 255) {
      continue;
    }

    $id = db_insert('reol_review_reviews')
      ->fields(array(
        'isbn' => $isbn,
        'link' => $link,
        'process' => 1,
        'created' => $review->credate,
        'description' => $review->description,
      ))
      ->execute();

    $queue->createItem($id);
  }

  return TRUE;
}

/**
 * Cron queue callback.
 *
 * Processes one item.
 */
function reol_review_process_queue($rrid) {
  $review = db_select('reol_review_reviews', 'r')
    ->fields('r')
    ->condition('rrid', $rrid)
    ->execute()
    ->fetch();

  if (!$review) {
    watchdog('reol_review', 'Could not load queued review rrid @rrid', array('@rrid' => $rrid), WATCHDOG_ERROR);
    return;
  }

  $isbn = reol_base_convert_to_isbn($review->isbn);

  if ($isbn) {
    // We have to explicitly search for each title, instead
    // of searching for more at a time, as the ISBN-number they are
    // found on is not necessarily their own, it could be the physical
    // books ISBN. Therefore there is no way to map a result to the
    // one fetched from Ding, if searches are not done on each result.
    module_load_include('client.inc', 'ting');
    $ting_result = ting_do_search($isbn);
    if ($ting_result) {
      // If we have found exactly one.
      // If more have been found we cannot count on the results.
      if ($ting_result->numTotalObjects == 1) {
        list($ding_entity_id) = array_keys($ting_result->collections);
        $ting_entity = ding_entity_load($ding_entity_id);

        // Make sure the title does exist in publizon
        // and that the title has a cover.
        $product = publizon_get_product_cover($ting_entity->localId);

        // If it does, we add the info to our table.
        if ($product) {
          $type = reol_base_get_type_name($ting_entity->type);
          if ($type) {
            $review->type = $type;
            $review->ding_entity_id = $ding_entity_id;
          }
        }

      }
    }
    else {
      watchdog('reol_review', 'Ting search failed.', array(), WATCHDOG_WARNING);
    }

  }

  $review->process = 0;
  $review->processed = REQUEST_TIME;
  db_update('reol_review_reviews')
    ->fields(array(
      'process' => $review->process,
      'processed' => $review->processed,
      'type' => $review->type,
      'ding_entity_id' => $review->ding_entity_id,
    ))
    ->condition('rrid', $review->rrid)
    ->execute();
}
